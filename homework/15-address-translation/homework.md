[relocation.py README](https://github.com/remzi-arpacidusseau/ostep-homework/blob/master/vm-mechanism/README.md)

1. Run with seeds 1, 2, and 3, and compute whether each virtual address generated by the process is in or out of bounds. If in bounds, compute the translation.

    ```sh
    mike@DESKTOP-EO1SSPM ~/projects/ostep-homework/homework/15-address-translation (master)$ python3 relocation.py -s 1

    ARG seed 1
    ARG address space size 1k
    ARG phys mem size 16k

    Base-and-Bounds register information:

      Base   : 0x0000363c (decimal 13884)
      Limit  : 290

    Virtual Address Trace
      VA  0: 0x0000030e (decimal:  782) --> PA or segmentation violation?
      VA  1: 0x00000105 (decimal:  261) --> PA or segmentation violation?
      VA  2: 0x000001fb (decimal:  507) --> PA or segmentation violation?
      VA  3: 0x000001cc (decimal:  460) --> PA or segmentation violation?
      VA  4: 0x0000029b (decimal:  667) --> PA or segmentation violation?

    For each virtual address, either write down the physical address it translates to
    OR write down that it is an out-of-bounds address (a segmentation violation). For
    this problem, you should assume a simple virtual address space of a given size.
    ```

I think it's YES, NO, YES, YES, YES. The rest are pretty easy. If the decimal value is above the limit, it is a violation. If not, it isn't. Don't need to do any arithmetic it seems.

2. Run with these flags: -s 0 -n 10. What value do you have set -l (the bounds register) to in order to ensure that all the generated virtual addresses are within bounds?

  930. The highest memory range is 929, so one more than that.

    ```sh
    mike@DESKTOP-EO1SSPM ~/projects/ostep-homework/homework/15-address-translation (master)$ python3 relocation.py -s 0 -n 10 -l 930 -c

  ARG seed 0
  ARG address space size 1k
  ARG phys mem size 16k

  Base-and-Bounds register information:

    Base   : 0x0000360b (decimal 13835)
    Limit  : 930

  Virtual Address Trace
    VA  0: 0x00000308 (decimal:  776) --> VALID: 0x00003913 (decimal: 14611)
    VA  1: 0x000001ae (decimal:  430) --> VALID: 0x000037b9 (decimal: 14265)
    VA  2: 0x00000109 (decimal:  265) --> VALID: 0x00003714 (decimal: 14100)
    VA  3: 0x0000020b (decimal:  523) --> VALID: 0x00003816 (decimal: 14358)
    VA  4: 0x0000019e (decimal:  414) --> VALID: 0x000037a9 (decimal: 14249)
    VA  5: 0x00000322 (decimal:  802) --> VALID: 0x0000392d (decimal: 14637)
    VA  6: 0x00000136 (decimal:  310) --> VALID: 0x00003741 (decimal: 14145)
    VA  7: 0x000001e8 (decimal:  488) --> VALID: 0x000037f3 (decimal: 14323)
    VA  8: 0x00000255 (decimal:  597) --> VALID: 0x00003860 (decimal: 14432)
    VA  9: 0x000003a1 (decimal:  929) --> VALID: 0x000039ac (decimal: 14764)
    ```

3. Run with these flags: -s 1 -n 10 -l 100. What is the maximum value that base can be set to, such that the address space still fits into physical memory in its entirety?
    Multiply physical memory size by 1024, and subtract limit to get make base.
    16k (16 *1024) - 100 = 16284

4. Run some of the same problems above, but with larger address spaces (-a) and physical memories (-p).

    Mostly seems the same, but the numbers are bigger. Obviously if you don't increase limit you run into oodles of segmentation errors.

5. What fraction of randomly-generated virtual addresses are valid, as a function of the value of the bounds register? Make a graph from running with different random seeds, with limit values ranging from 0 up to the maximum size of the address space.

    after increasing limit to a certain size you converge on 100% of virtual addresses being valid, which doesn't seem entirely right. Not sure I worked things correctly.